import java.io.*;
import java.util.LinkedList;
import java.util.ArrayList;

/*
	Main is part of SlicerDroid.

	SlicerDroid is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	SlicerDroid is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with SlicerDroid.  If not, see <http://www.gnu.org/licenses/>.
*/

public class Main {
	
	/*
	 * Builds a file containing the whole string named 'text' written inside and names it as 'fileName' 
	 */
	private static void make_file(String fileName, String text){
		try {
			FileWriter fw = new FileWriter(fileName);
			PrintWriter pw = new PrintWriter(fw);
			pw.print(text);
			pw.close();
			fw.close();
		} catch(Exception e) {
			e.printStackTrace();
		}
	}
	
	/*
	 * Returns, if any errors in the arguments, the position of those mistakes in 'args'
	 */
	private static ArrayList<Integer> argsAreRight(String [] args){
		ArrayList<Integer> res = new ArrayList<Integer> ();
		int j=0;
		String [] slice_vars;
		for(int i=0; i<args.length; i++){
			j = i; 
			if(args[i].toLowerCase().equalsIgnoreCase("-png"))
				j++;
			if(args[i].toLowerCase().equalsIgnoreCase("-dot"))
				j++;
			if(args[i].toLowerCase().equalsIgnoreCase("-cfg"))
				j++;
			if(args[i].toLowerCase().equalsIgnoreCase("-cdg"))
				j++;
			if(args[i].toLowerCase().equalsIgnoreCase("-pdg"))
				j++;
			if(args[i].toLowerCase().equalsIgnoreCase("-pdt"))
				j++;
			if(args[i].toLowerCase().equalsIgnoreCase("-slice")){
				try {
					slice_vars = args[i+2].split(",");
					boolean allVars = true; // flag meant to control that all of the variables are well-written, 
					// that is to say, all of them begin with letter v (it does not matter upper case or lower case) 
					for(int k=0; k<slice_vars.length; k++){
						if(!(slice_vars[k].substring(0,1).equalsIgnoreCase("v"))){
							allVars = false; // this means that one of them is badly-written
						}	
					}
					if(allVars){
						j += 3;
						i += 2;
					}
				} catch (ArrayIndexOutOfBoundsException e) { /* there are no variables written on input command line */ }
			}
			if(i!=j-1) // if j was not increased by 1, this means there is something badly-written within the arguments
				res.add(i);
		}
		return res;
	}
	
	public static void main(String [] args) {
		String slicing_point = "0";	// slicing point is seted to 0, because it is a line 
									// of code that exists in every AG and also because 
									// I do not know if the user is going to want to make slicing or not!
		LinkedList<String> list = new LinkedList<String>();	// the list of variables is empty in the beginning 
															// because I do not know if the user is going to want to make slicing or not!
		boolean png = false;
		boolean dot = false;
		boolean cfg = false;
		boolean cdg = false;
		boolean pdg = false;
		boolean postdt = false;
		boolean slice = false;
		String [] slice_vars;
		
		if((args.length==1)&&(args[0].toLowerCase().equalsIgnoreCase("-help"))){	// help was required
			System.out.println("*******************************************************************");
			System.out.println("** Use any of the following flags to run SlicerDroid:            **");
			System.out.println("** -dot (in case you want a DOT file as an output)               **");
			System.out.println("** -png (in case you want a PNG file as an output)               **");
			System.out.println("** Note: if you don't type either -dot or -png, you will have    **");
			System.out.println("** no output.                                                    **");
			System.out.println("** -cfg (in case you want Control Flow Graph as an output)       **");
			System.out.println("** -cdg (in case you want Control Dependence Graph as an output) **");
			System.out.println("** -pdg (in case you want Program Dependence Graph as an output) **");
			System.out.println("** -pdt (in case you want Post Dominator Tree as an output)      **");
			System.out.println("** -slice <line-number> <list-of-variables>                      **");
			System.out.println("** (in case you want a slice of your AG input file)              **");
			System.out.println("** <line-number> : existing hexadecimal number in the input file **");
			System.out.println("** <list-of-variables> : input file's variables written all      **");
			System.out.println("** together but separated by commas in any desired order, e.g:   **");
			System.out.println("** -slice f0 v2,v3,v0                                            **");
			System.out.println("** Note: flags can be written in any order, only slice flag has  **");
			System.out.println("** to be followed by line number and list of variables           **");
			System.out.println("*******************************************************************");
		} else {
			if(argsAreRight(args).isEmpty()){
				for(int i=0; i<args.length; i++){
					if(args[i].toLowerCase().equalsIgnoreCase("-png"))
						png = true;
					if(args[i].toLowerCase().equalsIgnoreCase("-dot"))
						dot = true;
					if(args[i].toLowerCase().equalsIgnoreCase("-cfg"))
						cfg = true;
					if(args[i].toLowerCase().equalsIgnoreCase("-cdg"))
						cdg = true;
					if(args[i].toLowerCase().equalsIgnoreCase("-pdg"))
						pdg = true;
					if(args[i].toLowerCase().equalsIgnoreCase("-pdt"))
						postdt = true;
					if(args[i].toLowerCase().equalsIgnoreCase("-slice")){
						slice = true;
						slicing_point = args[i+1];
						slice_vars = args[i+2].split(",");
						for(int j=0; j<slice_vars.length; j++){
							list.add(slice_vars[j]);
						}		
					}	
				}

				// read_file.c
				String text = "#include<stdio.h>\n";
				text += "#include";
				text += '"';
				text += "defs.h";
				text += '"';
				text += "\n";
				text += "\n";
				text += "/*\n";
				text += "* This program filters the prologue\n";
				text += "*/\n";
				text += "\n";
				text += "int main(int argc, char *argv[])\n";
				text += "{\n";
				text += "	char str[MAX];\n";
				text += "	char c;\n";
				text += "	FILE *infile;\n";
				text += "	FILE *outfile;\n";
				text += "	infile = fopen(argv[1],";
				text += '"';
				text += "r";
				text += '"';
				text += "); // opens file passed as a parameter\n";
				text += "	if(infile==NULL)\n";
				text += "	{\n";
				text += "		printf(";
				text += '"';
				text += "\\nUnable to open %s";
				text += '"';
				text += ",argv[1]);\n";
				text += "		return 1;\n";
				text += "	}\n";
				text += "	outfile = fopen(";
				text += '"';
				text += "outfile.txt";
				text += '"';
				text += ",";
				text += '"';
				text += "w";
				text += '"';
				text += ");\n";
				text += "	if(outfile==NULL)\n";
				text += "	{\n";
				text += "		printf(";
				text += '"';
				text += "\\nUnable to open outfile.txt";
				text += '"';
				text += ");\n";
				text += "		return 1;\n";
				text += "	}\n";
				text += "	c = '#';\n";
				text += "	while (c == '#')\n";
				text += "	{\n";
				text += "		fscanf(infile,";
				text += '"';
				text += "%c";
				text += '"';
				text += ", &c);\n";
				text += "		fgets(str,MAX,infile);	\n";
				text += "	}\n";
				text += "	while (feof(infile) == 0)\n";
				text += "	{\n";
				text += "		fprintf(outfile, ";
				text += '"';
				text += "%s";
				text += '"';
				text += ", str); 	\n";
				text += "		fgets(str,MAX,infile);\n";
				text += "	}\n";
				text += "	fprintf(outfile,";
				text += '"';
				text += "@ NODE_END";
				text += '"';
				text += ");\n";
				text += "	fclose(infile);\n";
				text += "	fclose(outfile);\n";
				text += "	return 0;\n";
				text += "}\n";
				make_file("read_file.c",text);
				
				// defs.h
				text = "#define MAX 500\n";
				text += "\n";
				text += "/*\n";
				text += "* length: returns the string passed as a parameter's length\n";
				text += "*/\n";
				text += "int length(char a[MAX])\n";
				text += "{\n";
				text += "	int i;\n";
				text += "	int res = 0;\n";
				text += "	for(i=0; i<MAX; i++)\n";
				text += "	{	\n";
				text += "		switch (a[i]) \n";
				text += "		{\n";
				text += "			case '";
				text += "\\";
				text += "n' : i = MAX; break;\n";
				text += "			default : res++; break;\n";
				text += "		}\n";
				text += "	}\n";
				text += "	return res;	\n";
				text += "}\n";
				make_file("defs.h",text);
				
				// read_file2.c
				text = "#include<stdio.h>\n";
				text += "#include";
				text += '"';
				text += "defs.h";
				text += '"';
				text += "\n";
				text += "\n";
				text += "/*\n";
				text += "* This program filters the top of each node with @ and []\n";
				text += "*/ \n";
				text += "\n";
				text += "/*\n";
				text += "* nodeWithSuccessors: checks if the string passed as a parameter has at least\n";
				text += "* a @, two points and a clasp that opens and a clasp that closes\n";
				text += "*/\n";
				text += "int nodeWithSuccessors(char a[MAX])\n";
				text += "{\n";
				text += "	int i,at,two_points,opening_clasp,closing_clasp;\n";
				text += "	at = 0;\n";
				text += "	two_points = 0;\n";
				text += "	opening_clasp = 0;\n";
				text += "	closing_clasp = 0;\n";
				text += "	for(i=0; i<MAX; i++)\n";
				text += "	{\n";
				text += "		switch (a[i]) \n";
				text += "		{\n";
				text += "			case '@' : at = 1; break;\n";
				text += "			case ':' : two_points = 1; break;\n";
				text += "			case '[' : opening_clasp = 1; break;\n";
				text += "			case ']' : closing_clasp = 1; break;\n";
				text += "			case '";
				text += "\\";
				text += "n' : i = MAX; break;\n";
				text += "			default : break;\n";
				text += "		} 	\n";
				text += "	}\n";
				text += "	if ((at)&&(two_points)&&(opening_clasp)&&(closing_clasp))\n";
				text += "	// It's greater than or equal because if there are AT's(@), there is more than one; \n";
				text += "	// but if there are at least four, it means that's the beginning of the node\n";
				text += "		return 1; // returns TRUE\n";
				text += "	else	\n";
				text += "		return 0; // returns FALSE\n";
				text += "}\n";
				text += "\n";
				text += "/*\n";
				text += "* nodeWithoutSuccessors: checks if the string passed as a parameter has \n";
				text += "* a @ and two points (count must be equal to two, otherwise it's false)\n";
				text += "*/\n";
				text += "int nodeWithoutSuccessors(char a[MAX])\n";
				text += "{\n";
				text += "	int i,count;\n";
				text += "	count = 0;\n";
				text += "	for(i=0; i<MAX; i++)\n";
				text += "	{\n";
				text += "		switch (a[i]) \n";
				text += "		{\n";
				text += "			case '@' : count++; break;\n";
				text += "			case ':' : count++; break;\n";
				text += "			case '";
				text += "\\";
				text += "n' : i = MAX; break;\n";
				text += "			default : break;\n";
				text += "		} 	\n";
				text += "	}\n";
				text += "	if (count == 2) \n";
				text += "		return 1; // returns TRUE\n";
				text += "	else	\n";
				text += "		return 0; // returns FALSE\n";
				text += "}\n";
				text += "\n";
				text += "/*\n";
				text += "* empty: checks if the string passed as a parameter is empty. \n";
				text += "* (if so, it means that's the end of a node)\n";
				text += "*/\n";
				text += "int empty(char a[MAX])\n";
				text += "{\n";
				text += "	int i,isEmpty;\n";
				text += "	isEmpty = 0;\n";
				text += "	for(i=0; i<MAX; i++)\n";
				text += "	{\n";
				text += "		switch (a[i]) \n";
				text += "		{\n";
				text += "			case '";
				text += "\\";
				text += "n' : isEmpty = (i==0); i = MAX; break;\n";
				text += "			default : break;\n";
				text += "		} 	\n";
				text += "	}\n";
				text += "	return isEmpty;\n";
				text += "}\n";
				text += "\n";
				text += "/*\n";
				text += "* filter_hexa_number: filters every hexadecimal number which appears in the beginning of a node\n";
				text += "*/\n";
				text += "void filter_hexa_number(char a[MAX], FILE *f) \n";
				text += "{\n";
				text += "	fprintf(f,";
				text += '"';
				text += "@ ";
				text += '"';
				text += ");\n";
				text += "	int write,i;\n";
				text += "	write = 0;	\n";
				text += "	for(i=0; i<MAX; i++)\n";
				text += "	{	\n";
				text += "		switch (a[i]) \n";
				text += "		{\n";
				text += "			case 'x' : write = 1; break;\n";
				text += "			case 'a' : if(write) fprintf(f,";
				text += '"';
				text += "a";
				text += '"';
				text += "); break;\n";
				text += "			case 'b' : if(write) fprintf(f,";
				text += '"';
				text += "b";
				text += '"';
				text += "); break;\n";
				text += "			case 'c' : if(write) fprintf(f,";
				text += '"';
				text += "c";
				text += '"';
				text += "); break;\n";
				text += "			case 'd' : if(write) fprintf(f,";
				text += '"';
				text += "d";
				text += '"';
				text += "); break;\n";
				text += "			case 'e' : if(write) fprintf(f,";
				text += '"';
				text += "e";
				text += '"';
				text += "); break;\n";
				text += "			case 'f' : if(write) fprintf(f,";
				text += '"';
				text += "f";
				text += '"';
				text += "); break;\n";
				text += "			case ' ' : if(write) fprintf(f,";
				text += '"';
				text += " ";
				text += "\\";
				text += "n@ ";
				text += '"';
				text += "); write = 0; break;\n";
				text += "			case '0' : if(write) fprintf(f,";
				text += '"';
				text += "0";
				text += '"';
				text += "); break;\n";
				text += "			case '1' : if(write) fprintf(f,";
				text += '"';
				text += "1";
				text += '"';
				text += "); break;\n";
				text += "			case '2' : if(write) fprintf(f,";
				text += '"';
				text += "2";
				text += '"';
				text += "); break;\n";
				text += "			case '3' : if(write) fprintf(f,";
				text += '"';
				text += "3";
				text += '"';
				text += "); break;\n";
				text += "			case '4' : if(write) fprintf(f,";
				text += '"';
				text += "4";
				text += '"';
				text += "); break;\n";
				text += "			case '5' : if(write) fprintf(f,";
				text += '"';
				text += "5";
				text += '"';
				text += "); break;\n";
				text += "			case '6' : if(write) fprintf(f,";
				text += '"';
				text += "6";
				text += '"';
				text += "); break;\n";
				text += "			case '7' : if(write) fprintf(f,";
				text += '"';
				text += "7";
				text += '"';
				text += "); break;\n";
				text += "			case '8' : if(write) fprintf(f,";
				text += '"';
				text += "8";
				text += '"';
				text += "); break;\n";
				text += "			case '9' : if(write) fprintf(f,";
				text += '"';
				text += "9";
				text += '"';
				text += "); break;\n";
				text += "			case '";
				text += "\\";
				text += "n' : i = MAX; break;\n";
				text += "		}\n";
				text += "	}	\n";
				text += "	fprintf(f,";
				text += '"';
				text += "\\";
				text += "n";
				text += '"';
				text += ");	\n";
				text += "}\n";
				text += "\n";
				text += "int main(int argc, char *argv[])\n";
				text += "{\n";
				text += "	char str[MAX];\n";
				text += "	FILE *infile;\n";
				text += "	FILE *outfile;\n";
				text += "	infile = fopen(argv[1],";
				text += '"';
				text += "r";
				text += '"';
				text += "); // opens file passed as a parameter\n";
				text += "	if(infile==NULL)\n";
				text += "	{\n";
				text += "		printf(";
				text += '"';
				text += "\\nUnable to open %s";
				text += '"';
				text += ",argv[1]);\n";
				text += "		return 1;\n";
				text += "	}\n";
				text += "	outfile = fopen(";
				text += '"';
				text += "outfile2.txt";
				text += '"';
				text += ",";
				text += '"';
				text += "w";
				text += '"';
				text += ");\n";
				text += "	if(outfile==NULL)\n";
				text += "	{\n";
				text += "		printf(";
				text += '"';
				text += "\\nUnable to open outfile2.txt";
				text += '"';
				text += ");\n";
				text += "		return 1;\n";
				text += "	}\n";
				text += "	while (feof(infile) == 0)\n";
				text += "	{\n";
				text += "		fgets(str,MAX,infile);\n";
				text += "		if(empty(str))\n";
				text += "			fprintf(outfile,";
				text += '"';
				text += "@ NODE_END";
				text += "\\";
				text += "n";
				text += '"';
				text += ");\n";
				text += "		else{		\n";
				text += "			if (nodeWithSuccessors(str))\n";
				text += "			{\n";
				text += "				fprintf(outfile,";
				text += '"';
				text += "@ NODE_BEGIN";
				text += "\\";
				text += "n";
				text += '"';
				text += ");\n";
				text += "				filter_hexa_number(str,outfile);\n";
				text += "			}\n";
				text += "			else \n";
				text += "			{\n";
				text += "				if (nodeWithoutSuccessors(str))\n";
				text += "				{\n";
				text += "					fprintf(outfile,";
				text += '"';
				text += "@ NODE_BEGIN";
				text += "\\";
				text += "n";
				text += '"';
				text += ");\n";
				text += "					filter_hexa_number(str,outfile);\n";
				text += "				} 	\n";
				text += "				else \n";
				text += "					fprintf(outfile, ";
				text += '"';
				text += "%s";
				text += '"';
				text += ", str);\n";
				text += "			}\n";
				text += "		}	\n";
				text += "	}\n";
				text += "	fclose(infile);\n";
				text += "	fclose(outfile);\n";
				text += "	return 0;\n";
				text += "}\n";
				make_file("read_file2.c",text);
				
				// read_file3.c
				text = "#include<stdio.h>\n";
				text += "#include";
				text += '"';
				text += "defs.h";
				text += '"';
				text += "\n";
				text += "\n";
				text += "/*\n";
				text += "* This program filters the line numbers of all the exceptions which are between parenthesis\n";
				text += "*/\n";
				text += "\n";
				text += "/*\n";
				text += "* filter_exception_number: filters hexadecimal number which appears between parenthesis\n";
				text += "*/\n";
				text += "void filter_exception_number(char a[MAX], FILE *f) \n";
				text += "{ \n";
				text += "	int i,index;\n";
				text += "	fprintf(f,";
				text += '"';
				text += "$ ";
				text += '"';
				text += "); // '$' means that they are all successors to the last line within a node\n";
				text += "	index = 0; // siempre en la posicion index + 2 empieza el numero hexadecimal	\n";
				text += "	for(i=0; i<MAX; i++)\n";
				text += "	{\n";
				text += "		if(a[i]=='>')\n";
				text += "		{\n";
				text += "			index = i;\n";
				text += "			i = MAX;\n";
				text += "		}\n";
				text += "	}\n";
				text += "	for(i=index+2; i<MAX; i++)\n";
				text += "	{\n";
				text += "		switch(a[i])\n";
				text += "		{\n";
				text += "			case ' ': i = MAX; break;\n";
				text += "			default : fprintf(f,";
				text += '"';
				text += "%c";
				text += '"';
				text += ",a[i]); break;\n";
				text += "		}\n";
				text += "	}\n";
				text += "	fprintf(f,";
				text += '"';
				text += "\\";
				text += "n";
				text += '"';
				text += ");	\n";
				text += "}\n";
				text += "\n";
				text += "int main(int argc, char *argv[])\n";
				text += "{\n";
				text += "	char str[MAX];\n";
				text += "	FILE *infile;\n";
				text += "	FILE *outfile;\n";
				text += "	infile = fopen(argv[1],";
				text += '"';
				text += "r";
				text += '"';
				text += "); // opens file passed as a parameter\n";
				text += "	if(infile==NULL)\n";
				text += "	{\n";
				text += "		printf(";
				text += '"';
				text += "\\nUnable to open %s";
				text += '"';
				text += ",argv[1]);\n";
				text += "		return 1;\n";
				text += "	}\n";
				text += "	outfile = fopen(";
				text += '"';
				text += "outfile3.txt";
				text += '"';
				text += ",";
				text += '"';
				text += "w";
				text += '"';
				text += ");\n";
				text += "	if(outfile==NULL)\n";
				text += "	{\n";
				text += "		printf(";
				text += '"';
				text += "\\nUnable to open outfile3.txt";
				text += '"';
				text += ");\n";
				text += "		return 1;\n";
				text += "	}\n";
				text += "	while (feof(infile) == 0)\n";
				text += "	{\n";
				text += "		fgets(str,MAX,infile);\n";
				text += "		if((length(str)>=3)&&(str[1]=='('))\n";
				text += "			filter_exception_number(str,outfile);\n";
				text += "		else \n";
				text += "			fprintf(outfile,";
				text += '"';
				text += "%s";
				text += '"';
				text += ",str); // write str into outfile without any modification\n";
				text += "	}\n";
				text += "	fclose(infile);\n";
				text += "	fclose(outfile);\n";
				text += "	return 0;\n";
				text += "}\n";
				make_file("read_file3.c",text);
				
				// read_file4.c
				text = "#include<stdio.h>\n";
				text += "#include";
				text += '"';
				text += "defs.h";
				text += '"';
				text += "\n";
				text += "\n";
				text += "/*\n";
				text += "* ignore: in case it returns true, string passed as a parameter must be written\n";
				text += "* into outfile without any modification\n";
				text += "*/\n";
				text += "int ignore(char a[MAX])\n";
				text += "{\n";
				text += "	if ((a[0]=='@')||(a[0]=='$'))\n";
				text += "		return 1;\n";
				text += "	else	\n";
				text += "		return 0;\n";
				text += "}\n";
				text += "\n";
				text += "/*\n";
				text += "* filter_hexa_number: filters every hexadecimal number which appears between parenthesis\n";
				text += "*/\n";
				text += "void filter_hexa_number(char a[MAX], FILE *f) \n";
				text += "{ \n";
				text += "	int i,index1,index2;\n";
				text += "	int flag = 1;\n";
				text += "	int zero = 0;\n";
				text += "	for(i=0; i<MAX; i++)\n";
				text += "	{\n";
				text += "		if(a[i]=='(')\n";
				text += "		{\n";
				text += "			index1=i+1;\n";
				text += "			i = MAX;\n";
				text += "		}\n";
				text += "	}\n";
				text += "	for(i=index1; i<MAX; i++)\n";
				text += "	{\n";
				text += "		if(a[i]!='0')\n";
				text += "		{\n";
				text += "			index2=i;\n";
				text += "			i = MAX;\n";
				text += "		} else\n";
				text += "			zero++; // count the amount of zeros that appear in the line\n";
				text += "	}\n";
				text += "	if(zero==8) // this means it was a zero -> (00000000)\n";
				text += "		fprintf(f,";
				text += '"';
				text += "0";
				text += '"';
				text += ");\n";
				text += "	for(i=index2; i<MAX; i++)\n";
				text += "	{\n";
				text += "		switch (a[i])\n";
				text += "		{\n";
				text += "			case ')' : if(flag) flag = 0; else fprintf(f,";
				text += '"';
				text += "%c";
				text += '"';
				text += ",a[i]); break;\n";
				text += "			case '";
				text += "\\";
				text += "n': fprintf(f,";
				text += '"';
				text += "\\";
				text += "n";
				text += '"';
				text += "); i = MAX; break;\n";
				text += "			default: fprintf(f,";
				text += '"';
				text += "%c";
				text += '"';
				text += ",a[i]); break;\n";
				text += "		}\n";
				text += "	}\n";
				text += "}\n";
				text += "\n";
				text += "int main(int argc, char *argv[])\n";
				text += "{\n";
				text += "	char str[MAX];\n";
				text += "	FILE *infile;\n";
				text += "	FILE *outfile;\n";
				text += "	infile = fopen(argv[1],";
				text += '"';
				text += "r";
				text += '"';
				text += "); // opens file passed as a parameter\n";
				text += "	if(infile==NULL)\n";
				text += "	{\n";
				text += "		printf(";
				text += '"';
				text += "\\nUnable to open %s";
				text += '"';
				text += ",argv[1]);\n";
				text += "		return 1;\n";
				text += "	}	\n";
				text += "	outfile = fopen(";
				text += '"';
				text += "outfile4.txt";
				text += '"';
				text += ",";
				text += '"';
				text += "w";
				text += '"';
				text += ");\n";
				text += "	if(outfile==NULL)\n";
				text += "	{\n";
				text += "		printf(";
				text += '"';
				text += "\\nUnable to open outfile4.txt";
				text += '"';
				text += ");\n";
				text += "		return 1;\n";
				text += "	}\n";
				text += "	while (feof(infile) == 0)\n";
				text += "	{\n";
				text += "		fgets(str,MAX,infile);\n";
				text += "		if (ignore(str))\n";
				text += "			fprintf(outfile,";
				text += '"';
				text += "%s";
				text += '"';
				text += ",str); // write str into outfile without any modification\n";
				text += "		else\n";
				text += "			filter_hexa_number(str,outfile);\n";
				text += "	}\n";
				text += "	fclose(infile);\n";
				text += "	fclose(outfile);\n";
				text += "	return 0;\n";
				text += "}\n";
				make_file("read_file4.c",text);
				
				// read_moves.c
				text = "#include<stdio.h>\n";
				text += "#include <string.h>\n";
				text += "#include <stdlib.h>\n";
				text += "#include";
				text += '"';
				text += "defs.h";
				text += '"';
				text += "\n";
				text += "\n";
				text += "/*\n";
				text += "* isMoveResult: returns true when the string passed as a parameter is equal to 'move-result'\n";
				text += "*/\n";
				text += "int isMoveResult(char a[MAX])\n";
				text += "{\n";
				text += "	int res = 0; // initial value is false (false == 0)\n";
				text += "	if(a[0]=='m') res++;	\n";
				text += "	if(a[1]=='o') res++;\n";
				text += "	if(a[2]=='v') res++;\n";
				text += "	if(a[3]=='e') res++;\n";
				text += "	if(a[4]=='-') res++;	\n";
				text += "	if(a[5]=='r') res++;\n";
				text += "	if(a[6]=='e') res++;\n";
				text += "	if(a[7]=='s') res++;\n";
				text += "	if(a[8]=='u') res++;	\n";
				text += "	if(a[9]=='l') res++;\n";
				text += "	if(a[10]=='t') res++;\n";
				text += "	if(res==11)\n";
				text += "		return 1;\n";
				text += "	else\n";
				text += "		return 0;\n";
				text += "}\n";
				text += "\n";
				text += "/*\n";
				text += "* isMoveResultWide: returns true when the string passed as a parameter is equal to 'move-result-wide'\n";
				text += "*/\n";
				text += "int isMoveResultWide(char a[MAX])\n";
				text += "{\n";
				text += "	int res = 0; // initial value is false (false == 0)\n";
				text += "	if(a[0]=='m') res++;	\n";
				text += "	if(a[1]=='o') res++;\n";
				text += "	if(a[2]=='v') res++;\n";
				text += "	if(a[3]=='e') res++;\n";
				text += "	if(a[4]=='-') res++;	\n";
				text += "	if(a[5]=='r') res++;\n";
				text += "	if(a[6]=='e') res++;\n";
				text += "	if(a[7]=='s') res++;\n";
				text += "	if(a[8]=='u') res++;	\n";
				text += "	if(a[9]=='l') res++;\n";
				text += "	if(a[10]=='t') res++;\n";
				text += "	if(a[11]=='-') res++;\n";
				text += "	if(a[12]=='w') res++;\n";
				text += "	if(a[13]=='i') res++;\n";
				text += "	if(a[14]=='d') res++;\n";
				text += "	if(a[15]=='e') res++;\n";
				text += "	if(res==16)\n";
				text += "		return 1;\n";
				text += "	else\n";
				text += "		return 0;\n";
				text += "}\n";
				text += "\n";
				text += "/*\n";
				text += "* isMoveResultObject: returns true when the string passed as a parameter is equal to 'move-result-object'\n";
				text += "*/\n";
				text += "int isMoveResultObject(char a[MAX])\n";
				text += "{\n";
				text += "	int res = 0; // initial value is false (false == 0)\n";
				text += "	if(a[0]=='m') res++;	\n";
				text += "	if(a[1]=='o') res++;\n";
				text += "	if(a[2]=='v') res++;\n";
				text += "	if(a[3]=='e') res++;\n";
				text += "	if(a[4]=='-') res++;	\n";
				text += "	if(a[5]=='r') res++;\n";
				text += "	if(a[6]=='e') res++;\n";
				text += "	if(a[7]=='s') res++;\n";
				text += "	if(a[8]=='u') res++;	\n";
				text += "	if(a[9]=='l') res++;\n";
				text += "	if(a[10]=='t') res++;\n";
				text += "	if(a[11]=='-') res++;\n";
				text += "	if(a[12]=='o') res++;\n";
				text += "	if(a[13]=='b') res++;\n";
				text += "	if(a[14]=='j') res++;\n";
				text += "	if(a[15]=='e') res++;\n";
				text += "	if(a[16]=='c') res++;\n";
				text += "	if(a[17]=='t') res++;\n";
				text += "	if(res==18)\n";
				text += "		return 1;\n";
				text += "	else\n";
				text += "		return 0;\n";
				text += "}\n";
				text += "\n";
				text += "/*\n";
				text += "* isMoveException: returns true when the string passed as a parameter is equal to 'move-exception'\n";
				text += "*/\n";
				text += "int isMoveException(char a[MAX])\n";
				text += "{\n";
				text += "	int res = 0; // initial value is false (false == 0)\n";
				text += "	if(a[0]=='m') res++;	\n";
				text += "	if(a[1]=='o') res++;\n";
				text += "	if(a[2]=='v') res++;\n";
				text += "	if(a[3]=='e') res++;\n";
				text += "	if(a[4]=='-') res++;\n";
				text += "	if(a[5]=='e') res++;\n";
				text += "	if(a[6]=='x') res++;\n";
				text += "	if(a[7]=='c') res++;\n";
				text += "	if(a[8]=='e') res++;\n";
				text += "	if(a[9]=='p') res++;\n";
				text += "	if(a[10]=='t') res++;\n";
				text += "	if(a[11]=='i') res++;\n";
				text += "	if(a[12]=='o') res++;\n";
				text += "	if(a[13]=='n') res++;\n";
				text += "	if(res==14)\n";
				text += "		return 1;\n";
				text += "	else\n";
				text += "		return 0;\n";
				text += "}\n";
				text += "\n";
				text += "int main(int argc, char *argv[])\n";
				text += "{\n";
				text += "	char line[MAX],part1[MAX],part2[MAX],part3[MAX];\n";
				text += "	int wasMove;\n";
				text += "	FILE *infile;\n";
				text += "	FILE *outfile1;\n";
				text += "	infile = fopen(argv[1],";
				text += '"';
				text += "r";
				text += '"';
				text += "); // opens file passed as a parameter\n";
				text += "	if(infile==NULL)\n";
				text += "	{\n";
				text += "		printf(";
				text += '"';
				text += "\\nUnable to open %s";
				text += '"';
				text += ",argv[1]);\n";
				text += "		return 1;\n";
				text += "	}	\n";
				text += "	outfile1 = fopen(";
				text += '"';
				text += "outfile7.txt";
				text += '"';
				text += ",";
				text += '"';
				text += "w";
				text += '"';
				text += ");\n";
				text += "	if(outfile1==NULL)\n";
				text += "	{\n";
				text += "		printf(";
				text += '"';
				text += "\\nUnable to open outfile7.txt";
				text += '"';
				text += ");\n";
				text += "		return 1;\n";
				text += "	}\n";
				text += "	while (feof(infile) == 0)\n";
				text += "	{\n";
				text += "		strcpy(part1,";
				text += '"';
				text += "";
				text += '"';
				text += ");\n";
				text += "		strcpy(part2,";
				text += '"';
				text += "";
				text += '"';
				text += ");\n";
				text += "		strcpy(part3,";
				text += '"';
				text += "";
				text += '"';
				text += ");\n";
				text += "		strcpy(line,";
				text += '"';
				text += "";
				text += '"';
				text += ");\n";
				text += "		fscanf(infile,";
				text += '"';
				text += "%s";
				text += '"';
				text += ",part1);\n";
				text += "		fscanf(infile,";
				text += '"';
				text += "%s";
				text += '"';
				text += ",part2);\n";
				text += "		wasMove = 0;\n";
				text += "		// rewrite 'moves' sentences, change size (8 bits) of destination registers according to the table\n";
				text += "		if((isMoveResult(part2))||(isMoveException(part2)))\n";
				text += "		{\n";
				text += "			fscanf(infile,";
				text += '"';
				text += "%s";
				text += '"';
				text += ",part3);\n";
				text += "			strcpy(part2,";
				text += '"';
				text += "move/from16";
				text += '"';
				text += ");\n";
				text += "			strcat(part3,";
				text += '"';
				text += ", v-1";
				text += '"';
				text += ");\n";
				text += "			wasMove = 1;\n";
				text += "		}\n";
				text += "		if(isMoveResultWide(part2))\n";
				text += "		{\n";
				text += "			fscanf(infile,";
				text += '"';
				text += "%s";
				text += '"';
				text += ",part3);\n";
				text += "			strcpy(part2,";
				text += '"';
				text += "move-wide/from16";
				text += '"';
				text += ");\n";
				text += "			strcat(part3,";
				text += '"';
				text += ", v-1";
				text += '"';
				text += ");	\n";
				text += "			wasMove = 1;	\n";
				text += "		}\n";
				text += "		if(isMoveResultObject(part2))\n";
				text += "		{\n";
				text += "			fscanf(infile,";
				text += '"';
				text += "%s";
				text += '"';
				text += ",part3);\n";
				text += "			strcpy(part2,";
				text += '"';
				text += "move-object/from16";
				text += '"';
				text += ");\n";
				text += "			strcat(part3,";
				text += '"';
				text += ", v-1";
				text += '"';
				text += ");\n";
				text += "			wasMove = 1;\n";
				text += "		}\n";
				text += "		fgets(line,MAX,infile); // the rest of the line\n";
				text += "		if(wasMove)\n";
				text += "		{\n";
				text += "			if(feof(infile) == 0)\n";
				text += "				fprintf(outfile1,";
				text += '"';
				text += "%s %s %s %s";
				text += '"';
				text += ",part1,part2,part3,line);			\n";
				text += "		}\n";
				text += "		else\n";
				text += "		{\n";
				text += "			if(feof(infile) == 0)			\n";
				text += "				fprintf(outfile1,";
				text += '"';
				text += "%s %s %s";
				text += '"';
				text += ",part1,part2,line);\n";
				text += "		}\n";
				text += "	}\n";
				text += "	fclose(infile);\n";
				text += "	fclose(outfile1);\n";
				text += "	return 0;\n";
				text += "}\n";
				make_file("read_moves.c",text);
				
				// read_nodes.c
				text = "#include<stdio.h>\n";
				text += "#include";
				text += '"';
				text += "defs.h";
				text += '"';
				text += "\n";
				text += "\n";
				text += "int main(int argc, char *argv[])\n";
				text += "{\n";
				text += "	int i;\n";
				text += "	char str[MAX];\n";
				text += "	FILE *infile;\n";
				text += "	FILE *outfileNodos;\n";
				text += "	infile = fopen(argv[1],";
				text += '"';
				text += "r";
				text += '"';
				text += "); // opens file passed as a parameter\n";
				text += "	if(infile==NULL)\n";
				text += "	{\n";
				text += "		printf(";
				text += '"';
				text += "\\nUnable to open %s";
				text += '"';
				text += ",argv[1]);\n";
				text += "		return 1;\n";
				text += "	}	\n";
				text += "	outfileNodos= fopen(";
				text += '"';
				text += "nodes.txt";
				text += '"';
				text += ",";
				text += '"';
				text += "w";
				text += '"';
				text += ");\n";
				text += "	if(outfileNodos==NULL)\n";
				text += "	{\n";
				text += "		printf(";
				text += '"';
				text += "\\nUnable to open nodes.txt";
				text += '"';
				text += ");\n";
				text += "		return 1;\n";
				text += "	}\n";
				text += "	int firstSpace = 0;\n";
				text += "	fgets(str,MAX,infile);	\n";
				text += "	while (feof(infile) == 0)\n";
				text += "	{\n";
				text += "		if(str[0]==' ')\n";
				text += "		{\n";
				text += "			for(i=1; str[i] !='";
				text += "\\";
				text += "n'; i++)\n";
				text += "			{	\n";
				text += "				firstSpace = 1;\n";
				text += "				fprintf(outfileNodos,";
				text += '"';
				text += "%c";
				text += '"';
				text += ", str[i]);\n";
				text += "			}\n";
				text += "			fprintf(outfileNodos, ";
				text += '"';
				text += "%c";
				text += '"';
				text += ", str[i]);\n";
				text += "		}\n";
				text += "		else 	\n";
				text += "			fprintf(outfileNodos, ";
				text += '"';
				text += "%s";
				text += '"';
				text += ", str);\n";
				text += "		firstSpace = 0;\n";
				text += "		fgets(str,MAX,infile);\n";
				text += "	}\n";
				text += "}\n";
				make_file("read_nodes.c",text);
				
				// read_nodes_intermediate.c
				text = "#include<stdio.h>\n";
				text += "#include";
				text += '"';
				text += "defs.h";
				text += '"';
				text += "\n";
				text += "\n";
				text += "/*\n";
				text += "* isNode: returns true when the string passed as a parameter parses as a node from the graph\n";
				text += "*/\n";
				text += "int isNode(char a[MAX]){\n";
				text += "	if ((a[0]!='@') && (a[0]!='$'))\n";
				text += "		return 1;\n";
				text += "	else	\n";
				text += "		return 0;\n";
				text += "}\n";
				text += "\n";
				text += "int main(int argc, char *argv[])\n";
				text += "{\n";
				text += "	int i;\n";
				text += "	char str[MAX];\n";
				text += "	FILE *infile;\n";
				text += "	FILE *outfileNodesIntermediate;\n";
				text += "	infile = fopen(argv[1],";
				text += '"';
				text += "r";
				text += '"';
				text += "); // opens file passed as a parameter\n";
				text += "	if(infile==NULL)\n";
				text += "	{\n";
				text += "		printf(";
				text += '"';
				text += "\\nUnable to open %s";
				text += '"';
				text += ",argv[1]);\n";
				text += "		return 1;\n";
				text += "	}	\n";
				text += "	outfileNodesIntermediate = fopen(";
				text += '"';
				text += "outfileNodesIntermediate.txt";
				text += '"';
				text += ",";
				text += '"';
				text += "w";
				text += '"';
				text += ");\n";
				text += "	if(outfileNodesIntermediate==NULL)\n";
				text += "	{\n";
				text += "		printf(";
				text += '"';
				text += "\\nUnable to open outfileNodesIntermediate.TXT";
				text += '"';
				text += ");\n";
				text += "		return 1;\n";
				text += "	}\n";
				text += "	fgets(str,MAX,infile);\n";
				text += "	while (feof(infile) == 0)\n";
				text += "	{\n";
				text += "		i=0;\n";
				text += "		if (isNode(str))\n";
				text += "		{\n";
				text += "			fprintf(outfileNodesIntermediate,";
				text += '"';
				text += "NAME ";
				text += "\\";
				text += "n";
				text += '"';
				text += ");\n";
				text += "			while (str[i] != ' ')\n";
				text += "			{\n";
				text += "				fprintf(outfileNodesIntermediate, ";
				text += '"';
				text += "%c";
				text += '"';
				text += ", str[i]);\n";
				text += "				i++;\n";
				text += "			}\n";
				text += "			fprintf(outfileNodesIntermediate,";
				text += '"';
				text += "\\n";
				text += '"';
				text += ");\n";
				text += "			while (str[i] == ' ') // Skip white space\n";
				text += "				i++;\n";
				text += "			fprintf(outfileNodesIntermediate,";
				text += '"';
				text += "ACTION ";
				text += "\\";
				text += "n";
				text += '"';
				text += ");\n";
				text += "			while (str[i] != ' ')\n";
				text += "			{\n";
				text += "				fprintf(outfileNodesIntermediate, ";
				text += '"';
				text += "%c";
				text += '"';
				text += ", str[i]);\n";
				text += "				i++;\n";
				text += "			}\n";
				text += "			fprintf(outfileNodesIntermediate,";
				text += '"';
				text += "\\n";
				text += '"';
				text += ");\n";
				text += "			while (str[i] == ' ') // Skip white space\n";
				text += "				i++;			\n";
				text += "			fprintf(outfileNodesIntermediate,";
				text += '"';
				text += "PARAMETERS ";
				text += "\\";
				text += "n";
				text += '"';
				text += ");\n";
				text += "			while (str[i] != '\\n')\n";
				text += "			{\n";
				text += "				if(str[i] != '";
				text += '"';
				text += "') // if it is a double quote, it must be ignored! It's not written in the outfile\n";
				text += "				{ 					\n";
				text += "					if(str[i] == ',') // if it is a comma, a new line '\\n' is written, because it's a new parameter\n";
				text += "						fprintf(outfileNodesIntermediate,";
				text += '"';
				text += "\\n";
				text += '"';
				text += ");\n";
				text += "					else\n";
				text += "						fprintf(outfileNodesIntermediate, ";
				text += '"';
				text += "%c";
				text += '"';
				text += ", str[i]);\n";
				text += "				}\n";
				text += "				i++;\n";
				text += "			}\n";
				text += "			fprintf(outfileNodesIntermediate,";
				text += '"';
				text += "\\n";
				text += '"';
				text += ");\n";
				text += "		}\n";
				text += "		fgets(str,MAX,infile);	\n";
				text += "	}\n";
				text += "	fclose(infile);\n";
				text += "	fclose(outfileNodesIntermediate);\n";
				text += "	return 0;\n";
				text += "}\n";
				make_file("read_nodes_intermediate.c",text);
				
				// read_predecessors.c
				text = "#include<stdio.h>\n";
				text += "#include <string.h>\n";
				text += "#include";
				text += '"';
				text += "defs.h";
				text += '"';
				text += "\n";
				text += "\n";
				text += "/*\n";
				text += "* isVertex: returns true when the string passed as a parameter is equal to 'vertex'\n";
				text += "*/\n";
				text += "int isVertex(char a[MAX]) // vertex always has six characters\n";
				text += "{\n";
				text += "	int res = 0; // initial value is false (false == 0)\n";
				text += "	if(length(a)==6)\n";
				text += "	{\n";
				text += "		if(a[0]=='V') res++;	\n";
				text += "		if(a[1]=='E') res++;\n";
				text += "		if(a[2]=='R') res++;\n";
				text += "		if(a[3]=='T') res++;\n";
				text += "		if(a[4]=='E') res++;	\n";
				text += "		if(a[5]=='X') res++;\n";
				text += "	}	else\n";
				text += "		return res;\n";
				text += "	if(res==6)\n";
				text += "		return 1;\n";
				text += "	else\n";
				text += "		return 0;\n";
				text += "}\n";
				text += "\n";
				text += "/*\n";
				text += "* isVertex2: new version of isVertex, to see if the word read with scanf is vertex\n";
				text += "*/\n";
				text += "int isVertex2(char a[MAX]) \n";
				text += "{\n";
				text += "	int res = 0; // initial value is false (false == 0)\n";
				text += "	if(a[0]=='V') res++;	\n";
				text += "	if(a[1]=='E') res++;\n";
				text += "	if(a[2]=='R') res++;\n";
				text += "	if(a[3]=='T') res++;\n";
				text += "	if(a[4]=='E') res++;	\n";
				text += "	if(a[5]=='X') res++;\n";
				text += "	if(res==6)\n";
				text += "		return 1;\n";
				text += "	else\n";
				text += "		return 0;\n";
				text += "}\n";
				text += "\n";
				text += "/*\n";
				text += "* getSubstring: this ignores the white space, copying the resulting string into sub \n";
				text += "*/\n";
				text += "void getSubstring(char str[MAX],char sub[MAX]) \n";
				text += "{\n";
				text += "	int i = 1; \n";
				text += "	while(i<MAX)\n";
				text += "	{\n";
				text += "		switch (str[i])\n";
				text += "		{\n";
				text += "			case '\\n': sub[i-1] = '\\0'; i = MAX; break;\n";
				text += "			default : sub[i-1] = str[i]; break;\n";
				text += "		}\n";
				text += "		i++;\n";
				text += "	}\n";
				text += "}\n";
				text += "\n";
				text += "int main(int argc, char *argv[]){\n";
				text += "	char line[MAX],part1[MAX],part2[MAX],previous[MAX],aux[MAX]; // previous stores previous node's number\n";
				text += "	int first;\n";
				text += "	FILE *infile;\n";
				text += "	FILE *outfile1;\n";
				text += "	FILE *outfile2;\n";
				text += "	infile = fopen(argv[1],";
				text += '"';
				text += "r";
				text += '"';
				text += "); // opens file passed as a parameter\n";
				text += "	if(infile==NULL)\n";
				text += "	{\n";
				text += "		printf(";
				text += '"';
				text += "\\nUnable to open %s";
				text += '"';
				text += ",argv[1]);\n";
				text += "		return 1;\n";
				text += "	}	\n";
				text += "	outfile1 = fopen(";
				text += '"';
				text += "predecessors_intermediate1.txt";
				text += '"';
				text += ",";
				text += '"';
				text += "w";
				text += '"';
				text += ");\n";
				text += "	if(outfile1==NULL)\n";
				text += "	{\n";
				text += "		printf(";
				text += '"';
				text += "\\nUnable to open predecessors_intermediate1.txt";
				text += '"';
				text += ");\n";
				text += "		return 1;\n";
				text += "	}\n";
				text += "	first = 1;\n";
				text += "	fgets(line,MAX,infile);\n";
				text += "	while (feof(infile) == 0)\n";
				text += "	{\n";
				text += "		if(isVertex(line))\n";
				text += "		{\n";
				text += "			if(first)\n";
				text += "			{\n";
				text += "				first = 0;\n";
				text += "				fprintf(outfile1,";
				text += '"';
				text += "%s$ ";
				text += '"';
				text += ",line);\n";
				text += "			} \n";
				text += "			else\n";
				text += "				fprintf(outfile1,";
				text += '"';
				text += "#\\n%s$ ";
				text += '"';
				text += ",line);\n";
				text += "		}		\n";
				text += "		else\n";
				text += "			fprintf(outfile1,";
				text += '"';
				text += "%s";
				text += '"';
				text += ",line);\n";
				text += "		fgets(line,MAX,infile);	\n";
				text += "	}\n";
				text += "	fprintf(outfile1,";
				text += '"';
				text += "#\\n";
				text += '"';
				text += ");\n";
				text += "	fclose(infile);\n";
				text += "	fclose(outfile1);\n";
				text += "	infile = fopen(";
				text += '"';
				text += "predecessors_intermediate1.txt";
				text += '"';
				text += ",";
				text += '"';
				text += "r";
				text += '"';
				text += ");\n";
				text += "	if(infile==NULL)\n";
				text += "	{\n";
				text += "		printf(";
				text += '"';
				text += "\\nUnable to open predecessors_intermediate1.txt";
				text += '"';
				text += ");\n";
				text += "		return 1;\n";
				text += "	}	\n";
				text += "	outfile2 = fopen(";
				text += '"';
				text += "predecessors.txt";
				text += '"';
				text += ",";
				text += '"';
				text += "w";
				text += '"';
				text += ");\n";
				text += "	if(outfile2==NULL)\n";
				text += "	{\n";
				text += "		printf(";
				text += '"';
				text += "\\nUnable to open predecessors.txt";
				text += '"';
				text += ");\n";
				text += "		return 1;\n";
				text += "	}\n";
				text += "	fscanf(infile,";
				text += '"';
				text += "%s";
				text += '"';
				text += ",part1);\n";
				text += "	fgets(part2,MAX,infile);\n";
				text += "	while (feof(infile) == 0)\n";
				text += "	{\n";
				text += "		if(isVertex2(part1))\n";
				text += "			fprintf(outfile2,";
				text += '"';
				text += "%s\\n";
				text += '"';
				text += ",part1);\n";
				text += "		else \n";
				text += "		{\n";
				text += "			if(part1[0]=='$') \n";
				text += "			{ \n";
				text += "				getSubstring(part2,aux); // here, the white space is skipped, starting from the character in position 1 \n";
				text += "				strcpy(previous,aux);\n";
				text += "				strcat(previous,";
				text += '"';
				text += "\\n";
				text += '"';
				text += ");\n";
				text += "			}			\n";
				text += "			else\n";
				text += "			{\n";
				text += "				if(part1[0]=='#')\n";
				text += "					fprintf(outfile2,";
				text += '"';
				text += "%s";
				text += '"';
				text += ",previous);\n";
				text += "				else // it's a number, so it's written into the outfile just the way it is\n";
				text += "					fprintf(outfile2,";
				text += '"';
				text += "%s\\n";
				text += '"';
				text += ",part1);\n";
				text += "			}\n";
				text += "		}\n";
				text += "		fscanf(infile,";
				text += '"';
				text += "%s";
				text += '"';
				text += ",part1);\n";
				text += "		fgets(part2,MAX,infile);\n";
				text += "	}\n";
				text += "	fclose(infile);\n";
				text += "	fclose(outfile2);\n";
				text += "	return 0;\n";
				text += "}\n";
				make_file("read_predecessors.c",text);
				
				// read_range.c
				text = "#include<stdio.h>\n";
				text += "#include <string.h>\n";
				text += "#include <stdlib.h>\n";
				text += "#include";
				text += '"';
				text += "defs.h";
				text += '"';
				text += "\n";
				text += "\n";
				text += "/*\n";
				text += "* isInvokeVirtualRange: returns true when the string passed as a parameter is equal to 'invoke-virtual/range'\n";
				text += "*/\n";
				text += "int isInvokeVirtualRange(char a[MAX])\n";
				text += "{\n";
				text += "	int res = 0; // initial value is false (false == 0)\n";
				text += "	if(a[0]=='i') res++;	\n";
				text += "	if(a[1]=='n') res++;\n";
				text += "	if(a[2]=='v') res++;\n";
				text += "	if(a[3]=='o') res++;\n";
				text += "	if(a[4]=='k') res++;	\n";
				text += "	if(a[5]=='e') res++;\n";
				text += "	if(a[6]=='-') res++;\n";
				text += "	if(a[7]=='v') res++;\n";
				text += "	if(a[8]=='i') res++;	\n";
				text += "	if(a[9]=='r') res++;\n";
				text += "	if(a[10]=='t') res++;\n";
				text += "	if(a[11]=='u') res++;\n";
				text += "	if(a[12]=='a') res++;\n";
				text += "	if(a[13]=='l') res++;\n";
				text += "	if(a[14]=='/') res++;\n";
				text += "	if(a[15]=='r') res++;\n";
				text += "	if(a[16]=='a') res++;\n";
				text += "	if(a[17]=='n') res++;\n";
				text += "	if(a[18]=='g') res++;\n";
				text += "	if(a[19]=='e') res++;\n";
				text += "	if(res==20)\n";
				text += "		return 1;\n";
				text += "	else\n";
				text += "		return 0;\n";
				text += "}\n";
				text += "\n";
				text += "/*\n";
				text += "* isInvokeSuperRange: returns true when the string passed as a parameter is equal to 'invoke-super/range'\n";
				text += "*/\n";
				text += "int isInvokeSuperRange(char a[MAX]) \n";
				text += "{\n";
				text += "	int res = 0; // initial value is false (false == 0)\n";
				text += "	if(a[0]=='i') res++;	\n";
				text += "	if(a[1]=='n') res++;\n";
				text += "	if(a[2]=='v') res++;\n";
				text += "	if(a[3]=='o') res++;\n";
				text += "	if(a[4]=='k') res++;	\n";
				text += "	if(a[5]=='e') res++;\n";
				text += "	if(a[6]=='-') res++;\n";
				text += "	if(a[7]=='s') res++;\n";
				text += "	if(a[8]=='u') res++;	\n";
				text += "	if(a[9]=='p') res++;\n";
				text += "	if(a[10]=='e') res++;\n";
				text += "	if(a[11]=='r') res++;\n";
				text += "	if(a[12]=='/') res++;\n";
				text += "	if(a[13]=='r') res++;\n";
				text += "	if(a[14]=='a') res++;\n";
				text += "	if(a[15]=='n') res++;\n";
				text += "	if(a[16]=='g') res++;\n";
				text += "	if(a[17]=='e') res++;\n";
				text += "	if(res==18)\n";
				text += "		return 1;\n";
				text += "	else\n";
				text += "		return 0;\n";
				text += "}\n";
				text += "\n";
				text += "/*\n";
				text += "* isInvokeDirectRange: returns true when the string passed as a parameter is equal to 'invoke-direct/range'\n";
				text += "*/\n";
				text += "int isInvokeDirectRange(char a[MAX]) \n";
				text += "{\n";
				text += "	int res = 0; // initial value is false (false == 0)\n";
				text += "	if(a[0]=='i') res++;	\n";
				text += "	if(a[1]=='n') res++;\n";
				text += "	if(a[2]=='v') res++;\n";
				text += "	if(a[3]=='o') res++;\n";
				text += "	if(a[4]=='k') res++;	\n";
				text += "	if(a[5]=='e') res++;\n";
				text += "	if(a[6]=='-') res++;\n";
				text += "	if(a[7]=='d') res++;\n";
				text += "	if(a[8]=='i') res++;	\n";
				text += "	if(a[9]=='r') res++;\n";
				text += "	if(a[10]=='e') res++;\n";
				text += "	if(a[11]=='c') res++;\n";
				text += "	if(a[12]=='t') res++;\n";
				text += "	if(a[13]=='/') res++;\n";
				text += "	if(a[14]=='r') res++;\n";
				text += "	if(a[15]=='a') res++;\n";
				text += "	if(a[16]=='n') res++;\n";
				text += "	if(a[17]=='g') res++;\n";
				text += "	if(a[18]=='e') res++;\n";
				text += "	if(res==19)\n";
				text += "		return 1;\n";
				text += "	else\n";
				text += "		return 0;\n";
				text += "}\n";
				text += "\n";
				text += "/*\n";
				text += "* isInvokeStaticRange: returns true when the string passed as a parameter is equal to 'invoke-static/range'\n";
				text += "*/\n";
				text += "int isInvokeStaticRange(char a[MAX])\n";
				text += "{\n";
				text += "	int res = 0; // initial value is false (false == 0)\n";
				text += "	if(a[0]=='i') res++;	\n";
				text += "	if(a[1]=='n') res++;\n";
				text += "	if(a[2]=='v') res++;\n";
				text += "	if(a[3]=='o') res++;\n";
				text += "	if(a[4]=='k') res++;	\n";
				text += "	if(a[5]=='e') res++;\n";
				text += "	if(a[6]=='-') res++;\n";
				text += "	if(a[7]=='s') res++;\n";
				text += "	if(a[8]=='t') res++;	\n";
				text += "	if(a[9]=='a') res++;\n";
				text += "	if(a[10]=='t') res++;\n";
				text += "	if(a[11]=='i') res++;\n";
				text += "	if(a[12]=='c') res++;\n";
				text += "	if(a[13]=='/') res++;\n";
				text += "	if(a[14]=='r') res++;\n";
				text += "	if(a[15]=='a') res++;\n";
				text += "	if(a[16]=='n') res++;\n";
				text += "	if(a[17]=='g') res++;\n";
				text += "	if(a[18]=='e') res++;\n";
				text += "	if(res==19)\n";
				text += "		return 1;\n";
				text += "	else\n";
				text += "		return 0;\n";
				text += "}\n";
				text += "\n";
				text += "/*\n";
				text += "* isInvokeInterfaceRange: returns true when the string passed as a parameter is equal to 'invoke-interface/range'\n";
				text += "*/\n";
				text += "int isInvokeInterfaceRange(char a[MAX]) \n";
				text += "{\n";
				text += "	int res = 0; // initial value is false (false == 0)\n";
				text += "	if(a[0]=='i') res++;	\n";
				text += "	if(a[1]=='n') res++;\n";
				text += "	if(a[2]=='v') res++;\n";
				text += "	if(a[3]=='o') res++;\n";
				text += "	if(a[4]=='k') res++;	\n";
				text += "	if(a[5]=='e') res++;\n";
				text += "	if(a[6]=='-') res++;\n";
				text += "	if(a[7]=='i') res++;\n";
				text += "	if(a[8]=='n') res++;	\n";
				text += "	if(a[9]=='t') res++;\n";
				text += "	if(a[10]=='e') res++;\n";
				text += "	if(a[11]=='r') res++;\n";
				text += "	if(a[12]=='f') res++;\n";
				text += "	if(a[13]=='a') res++;\n";
				text += "	if(a[14]=='c') res++;\n";
				text += "	if(a[15]=='e') res++;\n";
				text += "	if(a[16]=='/') res++;\n";
				text += "	if(a[17]=='r') res++;\n";
				text += "	if(a[18]=='a') res++;\n";
				text += "	if(a[19]=='n') res++;\n";
				text += "	if(a[20]=='g') res++;\n";
				text += "	if(a[21]=='e') res++;\n";
				text += "	if(res==22)\n";
				text += "		return 1;\n";
				text += "	else\n";
				text += "		return 0;\n";
				text += "}\n";
				text += "\n";
				text += "/*\n";
				text += "* getSubstring: this ignores the white space, copying the resulting string into sub \n";
				text += "*/\n";
				text += "void getSubstring(char str[MAX],char sub[MAX]) \n";
				text += "{\n";
				text += "	int i = 1; \n";
				text += "	while(i<MAX)\n";
				text += "	{\n";
				text += "		switch (str[i])\n";
				text += "		{\n";
				text += "			case '\\n': sub[i-1] = '\\0'; i = MAX; break;\n";
				text += "			case ',': sub[i-1] = '\\0'; i = MAX; break;\n";
				text += "			default : sub[i-1] = str[i]; break;\n";
				text += "		}\n";
				text += "		i++;\n";
				text += "	}\n";
				text += "}\n";
				text += "\n";
				text += "/*\n";
				text += "* getInteger: returns the integer represented as a string(parameter)\n";
				text += "*/ \n";
				text += "int getInteger(char str[MAX])\n";
				text += "{\n";
				text += "	int res = 0;\n";
				text += "	int i = 0; \n";
				text += "	while(i<MAX)\n";
				text += "	{\n";
				text += "		switch (str[i])\n";
				text += "		{\n";
				text += "			case '\\0': i = MAX; break;\n";
				text += "			case '\\n': i = MAX; break;\n";
				text += "			case '0': res = (res*10); break;\n";
				text += "			case '1': res = (res*10)+1; break;\n";
				text += "			case '2': res = (res*10)+2; break;\n";
				text += "			case '3': res = (res*10)+3; break;\n";
				text += "			case '4': res = (res*10)+4; break;\n";
				text += "			case '5': res = (res*10)+5; break;\n";
				text += "			case '6': res = (res*10)+6; break;\n";
				text += "			case '7': res = (res*10)+7; break;\n";
				text += "			case '8': res = (res*10)+8; break;\n";
				text += "			case '9': res = (res*10)+9; break;\n";
				text += "		}\n";
				text += "		i++;\n";
				text += "	}\n";
				text += "	return res;\n";
				text += "}\n";
				text += "\n";
				text += "int main(int argc, char *argv[])\n";
				text += "{\n";
				text += "	char word [MAX],line[MAX],str[MAX];\n";
				text += "	char part1[MAX],part2[MAX],part3[MAX],part4[MAX];\n";
				text += "	char part5[MAX],part6[MAX],range0[MAX],range1[MAX];\n";
				text += "	FILE *infile;\n";
				text += "	FILE *outfile1;\n";
				text += "	FILE *outfile2;\n";
				text += "	infile = fopen(argv[1],";
				text += '"';
				text += "r";
				text += '"';
				text += "); // opens file passed as a parameter\n";
				text += "	if(infile==NULL)\n";
				text += "	{\n";
				text += "		printf(";
				text += '"';
				text += "\\nUnable to open %s";
				text += '"';
				text += ",argv[1]);\n";
				text += "		return 1;\n";
				text += "	}	\n";
				text += "	outfile1 = fopen(";
				text += '"';
				text += "outfile5.txt";
				text += '"';
				text += ",";
				text += '"';
				text += "w";
				text += '"';
				text += ");\n";
				text += "	if(outfile1==NULL)\n";
				text += "	{\n";
				text += "		printf(";
				text += '"';
				text += "\\nUnable to open outfile5.txt";
				text += '"';
				text += ");\n";
				text += "		return 1;\n";
				text += "	}\n";
				text += "	while (feof(infile) == 0)\n";
				text += "	{\n";
				text += "		fgets(str,MAX,infile);\n";
				text += "		if(!(str[0]=='@'))\n";
				text += "			fprintf(outfile1,";
				text += '"';
				text += "%s";
				text += '"';
				text += ",str);\n";
				text += "	}\n";
				text += "	fclose(infile);\n";
				text += "	fclose(outfile1);\n";
				text += "	infile = fopen(";
				text += '"';
				text += "outfile5.txt";
				text += '"';
				text += ",";
				text += '"';
				text += "r";
				text += '"';
				text += ");\n";
				text += "	if(infile==NULL)\n";
				text += "	{\n";
				text += "		printf(";
				text += '"';
				text += "\\nUnable to open outfile5.txt";
				text += '"';
				text += ");\n";
				text += "		return 1;\n";
				text += "	}\n";
				text += "	outfile2 = fopen(";
				text += '"';
				text += "outfile6.txt";
				text += '"';
				text += ",";
				text += '"';
				text += "w";
				text += '"';
				text += ");\n";
				text += "	if(outfile2==NULL)\n";
				text += "	{\n";
				text += "		printf(";
				text += '"';
				text += "\\nUnable to open outfile6.txt";
				text += '"';
				text += ");\n";
				text += "		return 1;\n";
				text += "	}	\n";
				text += "	while (feof(infile) == 0)\n";
				text += "	{\n";
				text += "		fscanf(infile,";
				text += '"';
				text += "%s";
				text += '"';
				text += ",part1);\n";
				text += "		fscanf(infile,";
				text += '"';
				text += "%s";
				text += '"';
				text += ",part2);\n";
				text += "		if((isInvokeVirtualRange(part2))||(isInvokeDirectRange(part2))||(isInvokeInterfaceRange(part2))||(isInvokeStaticRange(part2))||(isInvokeSuperRange(part2)))\n";
				text += "		{\n";
				text += "			// here, the range is written in a different manner\n";
				text += "			fscanf(infile,";
				text += '"';
				text += "%s";
				text += '"';
				text += ",part3);\n";
				text += "			fscanf(infile,";
				text += '"';
				text += "%s";
				text += '"';
				text += ",part4);\n";
				text += "			fscanf(infile,";
				text += '"';
				text += "%s";
				text += '"';
				text += ",part5);\n";
				text += "			fscanf(infile,";
				text += '"';
				text += "%s";
				text += '"';
				text += ",part6);\n";
				text += "			fgets(line,MAX,infile);\n";
				text += "			getSubstring(part3,range0);\n";
				text += "			getSubstring(part5,range1);\n";
				text += "			// the range is going to be well written into variable 'word'\n";
				text += "			int i;\n";
				text += "			char buffer [MAX]; \n";
				text += "			strcpy(word,";
				text += '"';
				text += "";
				text += '"';
				text += ");\n";
				text += "			for (i = getInteger(range0); i <= getInteger(range1); i++)\n";
				text += "			{ // in case there is a range, we assume that variables are always named V(number), and the range is defined from lower to higher\n";
				text += "				sprintf(buffer,";
				text += '"';
				text += "%d";
				text += '"';
				text += ",i);\n";
				text += "				strcat(word,buffer);\n";
				text += "				if(i==getInteger(range1))\n";
				text += "					strcat(word,";
				text += '"';
				text += ",";
				text += '"';
				text += ");\n";
				text += "				else\n";
				text += "						strcat(word,";
				text += '"';
				text += ", ";
				text += '"';
				text += ");\n";
				text += "			}\n";
				text += "			if(feof(infile) == 0)\n";
				text += "				fprintf(outfile2,";
				text += '"';
				text += "%s %s %s%s";
				text += '"';
				text += ",part1,part2,word,line);\n";
				text += "		} \n";
				text += "		else \n";
				text += "		{\n";
				text += "			fgets(line,MAX,infile);  // go along the whole line, and write it as it is\n";
				text += "			if(feof(infile) == 0)\n";
				text += "				fprintf(outfile2,";
				text += '"';
				text += "%s %s %s";
				text += '"';
				text += ",part1,part2,line);\n";
				text += "		}\n";
				text += "	}\n";
				text += "	fclose(infile);\n";
				text += "	fclose(outfile2);\n";
				text += "	return 0;\n";
				text += "}\n";
				make_file("read_range.c",text);
				
				// read_successors.c
				text = "#include<stdio.h>\n";
				text += "#include <string.h>\n";
				text += "#include";
				text += '"';
				text += "defs.h";
				text += '"';
				text += "\n";
				text += "\n";
				text += "/*\n";
				text += "* clean_line: clean empty spaces from the string passed as a parameter \n";
				text += "*/\n";
				text += "void clean_line(char a[MAX], FILE *f) \n";
				text += "{ \n";
				text += "	int i;\n";
				text += "	if(a[0]!='\\n')\n";
				text += "	{\n";
				text += "		for(i=0; i<MAX; i++)\n";
				text += "		{\n";
				text += "			switch (a[i])\n";
				text += "			{\n";
				text += "				case '\\n': fprintf(f,";
				text += '"';
				text += "\\n";
				text += '"';
				text += "); i = MAX; break;\n";
				text += "				case ' ': break; // SKIP, do nothing when a white space shows up\n";
				text += "				default: fprintf(f,";
				text += '"';
				text += "%c";
				text += '"';
				text += ",a[i]); break;\n";
				text += "			}\n";
				text += "		}\n";
				text += "	}\n";
				text += "}\n";
				text += "\n";
				text += "/*\n";
				text += "* isNodeBegin: returns true when the string passed as a parameter is the beginning of a node\n";
				text += "*/\n";
				text += "int isNodeBegin(char a[MAX]) // node begin always has twelve characters\n";
				text += "{\n";
				text += "	int res = 0; // initial value is false\n";
				text += "	if(length(a)==12)\n";
				text += "	{\n";
				text += "		if(a[0]=='@') res++;	\n";
				text += "		if(a[1]==' ') res++;\n";
				text += "		if(a[2]=='N') res++;\n";
				text += "		if(a[3]=='O') res++;\n";
				text += "		if(a[4]=='D') res++;	\n";
				text += "		if(a[5]=='E') res++;\n";
				text += "		if(a[6]=='_') res++;\n";
				text += "		if(a[7]=='B') res++;\n";
				text += "		if(a[8]=='E') res++;	\n";
				text += "		if(a[9]=='G') res++;\n";
				text += "		if(a[10]=='I') res++;\n";
				text += "		if(a[11]=='N') res++;\n";
				text += "	}	else\n";
				text += "		return res;\n";
				text += "	if(res==12)\n";
				text += "		return 1;\n";
				text += "	else\n";
				text += "		return 0;\n";
				text += "}\n";
				text += "\n";
				text += "/*\n";
				text += "* isNodeEnd: returns true when the string passed as a parameter is the end of a node\n";
				text += "*/\n";
				text += "int isNodeEnd(char a[MAX]) // node end always has ten characters\n";
				text += "{\n";
				text += "	int res = 0; // initial value is false\n";
				text += "	if(length(a)==10)\n";
				text += "	{\n";
				text += "		if(a[0]=='@') res++;	\n";
				text += "		if(a[1]==' ') res++;\n";
				text += "		if(a[2]=='N') res++;\n";
				text += "		if(a[3]=='O') res++;\n";
				text += "		if(a[4]=='D') res++;	\n";
				text += "		if(a[5]=='E') res++;\n";
				text += "		if(a[6]=='_') res++;\n";
				text += "		if(a[7]=='E') res++;\n";
				text += "		if(a[8]=='N') res++;	\n";
				text += "		if(a[9]=='D') res++;\n";
				text += "	}	else\n";
				text += "		return res;\n";
				text += "	if(res==10)\n";
				text += "		return 1;\n";
				text += "	else\n";
				text += "		return 0;\n";
				text += "}\n";
				text += "\n";
				text += "int main(int argc, char *argv[])\n";
				text += "{ \n";
				text += "	char line[MAX], previous[MAX]; // previous stores previous node's number\n";
				text += "	char str[MAX], part1[MAX], part2[MAX];\n";
				text += "	int first = 0;\n";
				text += "	FILE *infile;\n";
				text += "	FILE *outfile1;\n";
				text += "	FILE *outfile2;\n";
				text += "	FILE *outfile3;	\n";
				text += "	FILE *outfile4;\n";
				text += "	FILE *outfile5;	\n";
				text += "	infile = fopen(argv[1],";
				text += '"';
				text += "r";
				text += '"';
				text += "); // opens file passed as a parameter\n";
				text += "	if(infile==NULL)\n";
				text += "	{\n";
				text += "		printf(";
				text += '"';
				text += "\\nUnable to open %s";
				text += '"';
				text += ",argv[1]);\n";
				text += "		return 1;\n";
				text += "	}	\n";
				text += "	outfile1 = fopen(";
				text += '"';
				text += "successors_intermediate1.txt";
				text += '"';
				text += ",";
				text += '"';
				text += "w";
				text += '"';
				text += ");\n";
				text += "	if(outfile1==NULL)\n";
				text += "	{\n";
				text += "		printf(";
				text += '"';
				text += "\\nUnable to open successors_intermediate1.txt";
				text += '"';
				text += ");\n";
				text += "		return 1;\n";
				text += "	}\n";
				text += "	while (feof(infile) == 0)\n";
				text += "	{\n";
				text += "		fgets(str,MAX,infile);\n";
				text += "		if (isNodeBegin(str))\n";
				text += "			first = 1;			\n";
				text += "		else \n";
				text += "		{\n";
				text += "			if (isNodeEnd(str))\n";
				text += "				fprintf(outfile1,";
				text += '"';
				text += "#\\n";
				text += '"';
				text += ");\n";
				text += "			else\n";
				text += "			{	\n";
				text += "				if(first)\n";
				text += "					first = 0;\n";
				text += "				else\n";
				text += "				{\n";
				text += "					if((length(str)==2)&&(str[0]=='@'))\n";
				text += "						; // SKIP, do nothing\n";
				text += "					else\n";
				text += "		  			fprintf(outfile1,";
				text += '"';
				text += "%s";
				text += '"';
				text += ",str);\n";
				text += "				}\n";
				text += "			}\n";
				text += "		}\n";
				text += "	}\n";
				text += "	fclose(infile);\n";
				text += "	fclose(outfile1);\n";
				text += "	infile = fopen(";
				text += '"';
				text += "successors_intermediate1.txt";
				text += '"';
				text += ",";
				text += '"';
				text += "r";
				text += '"';
				text += ");\n";
				text += "	if(infile==NULL)\n";
				text += "	{\n";
				text += "		printf(";
				text += '"';
				text += "\\nUnable to open successors_intermediate1.txt";
				text += '"';
				text += ");\n";
				text += "		return 1;\n";
				text += "	}\n";
				text += "	outfile2 = fopen(";
				text += '"';
				text += "successors_intermediate2.txt";
				text += '"';
				text += ",";
				text += '"';
				text += "w";
				text += '"';
				text += ");\n";
				text += "	if(outfile2==NULL)\n";
				text += "	{\n";
				text += "		printf(";
				text += '"';
				text += "\\nUnable to open successors_intermediate2.txt";
				text += '"';
				text += ");\n";
				text += "		return 1;\n";
				text += "	}	\n";
				text += "	while (feof(infile) == 0)\n";
				text += "	{\n";
				text += "		fscanf(infile,";
				text += '"';
				text += "%s";
				text += '"';
				text += ",part1);\n";
				text += "		fgets(part2,MAX,infile);\n";
				text += "		if(part1[0]=='@')\n";
				text += "			fprintf(outfile2,";
				text += '"';
				text += "@%s";
				text += '"';
				text += ",part2);\n";
				text += "		else\n";
				text += "		{\n";
				text += "			if(part1[0]=='$')\n";
				text += "				fprintf(outfile2,";
				text += '"';
				text += "$%s";
				text += '"';
				text += ",part2);\n";
				text += "			else\n";
				text += "				fprintf(outfile2,";
				text += '"';
				text += "%s\\n";
				text += '"';
				text += ",part1);\n";
				text += "		}\n";
				text += "	}\n";
				text += "	fclose(infile);\n";
				text += "	fclose(outfile2);\n";
				text += "	infile = fopen(";
				text += '"';
				text += "successors_intermediate2.txt";
				text += '"';
				text += ",";
				text += '"';
				text += "r";
				text += '"';
				text += ");\n";
				text += "	if(infile==NULL)\n";
				text += "	{\n";
				text += "		printf(";
				text += '"';
				text += "\\nUnable to open successors_intermediate2.txt";
				text += '"';
				text += ");\n";
				text += "		return 1;\n";
				text += "	}\n";
				text += "	outfile3 = fopen(";
				text += '"';
				text += "successors_intermediate3.txt";
				text += '"';
				text += ",";
				text += '"';
				text += "w";
				text += '"';
				text += ");\n";
				text += "	if(outfile3==NULL)\n";
				text += "	{\n";
				text += "		printf(";
				text += '"';
				text += "\\nUnable to open successors_intermediate3.txt";
				text += '"';
				text += ");\n";
				text += "		return 1;\n";
				text += "	}\n";
				text += "	strcpy(line,";
				text += '"';
				text += "";
				text += '"';
				text += ");\n";
				text += "	first = 1;\n";
				text += "	while (feof(infile) == 0)\n";
				text += "	{\n";
				text += "		fscanf(infile,";
				text += '"';
				text += "%s";
				text += '"';
				text += ",part1);\n";
				text += "		fgets(part2,MAX,infile);\n";
				text += "		if(part1[0]=='#')\n";
				text += "		{\n";
				text += "			fprintf(outfile2,";
				text += '"';
				text += "%s";
				text += '"';
				text += ",line);\n";
				text += "			strcpy(line,";
				text += '"';
				text += "";
				text += '"';
				text += ");\n";
				text += "			first = 1;\n";
				text += "		} \n";
				text += "		else\n";
				text += "		{\n";
				text += "			if(part1[0]=='@')\n";
				text += "			{\n";
				text += "				strcat(line,";
				text += '"';
				text += "$";
				text += '"';
				text += ");\n";
				text += "				strcat(line,part2);	\n";
				text += "			}\n";
				text += "			else\n";
				text += "			{\n";
				text += "				if(part1[0]=='$')\n";
				text += "					fprintf(outfile3,";
				text += '"';
				text += "$%s";
				text += '"';
				text += ",part2);	\n";
				text += "				else // it's just this node's name  \n";
				text += "				{ \n";
				text += "					if (first)\n";
				text += "					{\n";
				text += "						fprintf(outfile3,";
				text += '"';
				text += "z %s\\n";
				text += '"';
				text += ",part1); // 'z' is used to indicate that this is a node's first tag\n";
				text += "						first = 0;\n";
				text += "					} \n";
				text += "					else\n";
				text += "						fprintf(outfile3,";
				text += '"';
				text += "%s\\n";
				text += '"';
				text += ",part1);\n";
				text += "				}				\n";
				text += "			}\n";
				text += "		}	\n";
				text += "	}\n";
				text += "	fclose(infile);\n";
				text += "	fclose(outfile3);\n";
				text += "	infile = fopen(";
				text += '"';
				text += "successors_intermediate3.txt";
				text += '"';
				text += ",";
				text += '"';
				text += "r";
				text += '"';
				text += ");\n";
				text += "	if(infile==NULL)\n";
				text += "	{\n";
				text += "		printf(";
				text += '"';
				text += "\\nUnable to open successors_intermediate3.txt";
				text += '"';
				text += ");\n";
				text += "		return 1;\n";
				text += "	}\n";
				text += "	outfile4 = fopen(";
				text += '"';
				text += "successors_intermediate4.txt";
				text += '"';
				text += ",";
				text += '"';
				text += "w";
				text += '"';
				text += ");\n";
				text += "	if(outfile4==NULL)\n";
				text += "	{\n";
				text += "		printf(";
				text += '"';
				text += "\\nUnable to open successors_intermediate4.txt";
				text += '"';
				text += ");\n";
				text += "		return 1;\n";
				text += "	}\n";
				text += "	first = 1; \n";
				text += "	while (feof(infile) == 0)\n";
				text += "	{\n";
				text += "		fscanf(infile,";
				text += '"';
				text += "%s";
				text += '"';
				text += ",part1);\n";
				text += "		fgets(part2,MAX,infile);\n";
				text += "		if(part1[0]=='$')\n";
				text += "		{\n";
				text += "			if(strcmp(previous,part2)!=0) // they both must not match\n";
				text += " 			{ \n";
				text += "				fprintf(outfile4,";
				text += '"';
				text += "VERTEX\\n";
				text += '"';
				text += ");\n";
				text += "				fprintf(outfile4,";
				text += '"';
				text += "%s\\n";
				text += '"';
				text += ",previous);\n";
				text += "				fprintf(outfile4,";
				text += '"';
				text += "%s\\n";
				text += '"';
				text += ",part2);\n";
				text += "			}\n";
				text += "		} \n";
				text += "		else \n";
				text += "		{\n";
				text += "			if (part1[0]=='z')\n";
				text += "				strcpy(previous,part2);\n";
				text += "			else\n";
				text += "			{\n";
				text += "				if(strcmp(previous,part1)!=0) // they both must not match\n";
				text += "				{ 				\n";
				text += "					fprintf(outfile4,";
				text += '"';
				text += "VERTEX\\n";
				text += '"';
				text += ");					\n";
				text += "					fprintf(outfile4,";
				text += '"';
				text += "%s\\n";
				text += '"';
				text += ",previous);\n";
				text += "					fprintf(outfile4,";
				text += '"';
				text += "%s\\n";
				text += '"';
				text += ",part1);\n";
				text += "					strcpy(previous,part1);\n";
				text += "				}\n";
				text += "			}\n";
				text += "		}				\n";
				text += "	}\n";
				text += "	fclose(infile);\n";
				text += "	fclose(outfile4);\n";
				text += "	infile = fopen(";
				text += '"';
				text += "successors_intermediate4.txt";
				text += '"';
				text += ",";
				text += '"';
				text += "r";
				text += '"';
				text += ");\n";
				text += "	if(infile==NULL)\n";
				text += "	{\n";
				text += "		printf(";
				text += '"';
				text += "\\nUnable to open successors_intermediate4.txt";
				text += '"';
				text += ");\n";
				text += "		return 1;\n";
				text += "	}\n";
				text += "	outfile5 = fopen(";
				text += '"';
				text += "successors.txt";
				text += '"';
				text += ",";
				text += '"';
				text += "w";
				text += '"';
				text += ");\n";
				text += "	if(outfile5==NULL)\n";
				text += "	{\n";
				text += "		printf(";
				text += '"';
				text += "\\nUnable to open successors.txt";
				text += '"';
				text += ");\n";
				text += "		return 1;\n";
				text += "	}\n";
				text += "	fgets(line,MAX,infile);\n";
				text += "	while (feof(infile) == 0)\n";
				text += "	{	\n";
				text += "		clean_line(line,outfile5); // clean empty lines and empty spaces\n";
				text += "		fgets(line,MAX,infile);	\n";
				text += "	}\n";
				text += "	fclose(infile);\n";
				text += "	fclose(outfile5);\n";
				text += "	return 0;\n";
				text += "}\n";
				make_file("read_successors.c",text);
				
				// process_AG.sh
				text = "#!/bin/bash\n";
				text += "# if output folder exists due to a previous run, it is removed so that it contains only new files\n";
				text += "if [ -d output ];\n";
				text += "then\n";
				text += "	cd output\n";
				text += "	rm *.png\n";
				text += "	rm *.dot\n";
				text += "	cd ..\n";
				text += "	rmdir output\n";
				text += "fi\n";
				text += "if [ -d .input ];\n";
				text += "then\n";
				text += "	rmdir .input\n";
				text += "fi\n";
				text += "mkdir .input\n";
				text += "echo ";
				text += '"';
				text += "*** Running SlicerDroid ***";
				text += '"';
				text += "\n";
				text += "echo Processing \\file: *.ag\n";
				text += "echo Progress:  \n";
				text += "gcc read_file.c -o read_file\n";
				text += "./read_file *.ag \n";
				text += "rm read_file\n";
				text += "gcc read_file2.c -o read_file2\n";
				text += "./read_file2 outfile.txt \n";
				text += "rm read_file2\n";
				text += "gcc read_file3.c -o read_file3\n";
				text += "./read_file3 outfile2.txt \n";
				text += "rm read_file3\n";
				text += "gcc read_file4.c -o read_file4\n";
				text += "./read_file4 outfile3.txt \n";
				text += "rm read_file4\n";
				text += "gcc read_successors.c -o read_successors\n";
				text += "./read_successors outfile4.txt \n";
				text += "rm read_successors\n";
				text += "gcc read_predecessors.c -o read_predecessors\n";
				text += "./read_predecessors successors.txt \n";
				text += "rm read_predecessors\n";
				text += "gcc read_range.c -o read_range\n";
				text += "./read_range outfile4.txt\n";
				text += "rm read_range\n";
				text += "gcc read_moves.c -o read_moves\n";
				text += "./read_moves outfile6.txt\n";
				text += "rm read_moves \n";
				text += "gcc read_nodes_intermediate.c -o read_nodes_intermediate\n";
				text += "./read_nodes_intermediate outfile7.txt \n";
				text += "rm read_nodes_intermediate\n";
				text += "gcc read_nodes.c -o read_nodes\n";
				text += "./read_nodes outfileNodesIntermediate.txt \n";
				text += "rm read_nodes\n";
				text += "cp successors.txt ./.input\n";
				text += "cp predecessors.txt ./.input\n";
				text += "cp nodes.txt ./.input\n";
				text += "rm *.txt\n";
				text += "rm *.c\n";
				text += "rm *.h\n";
				text += "# output_intermediate folder is created, so that Java program does not throw an exception and it can generate within it the appropriate DOT files\n";
				text += "if [ -d .output_intermediate ];\n";
				text += "then\n";
				text += "	rmdir .output_intermediate\n";
				text += "fi\n";
				text += "mkdir .output_intermediate\n";
				text += "# output folder is created, where all of the files required by the user will be found\n";
				text += "if [ -d .output ];\n";
				text += "then\n";
				text += "	rmdir .output\n";
				text += "fi\n";
				text += "mkdir .output \n";
				make_file(".process_AG.sh",text);
				
				// filter_files.sh
				text = "#!/bin/bash\n";
				text += "# 1 indicates option CDG && DOT\n";
				text += "if [ $1 -eq 1 ] ; then\n";
				text += "	cp .output_intermediate/CDG.dot ./.output\n";
				text += "fi\n";
				text += "# 2 indicates option CDG && PNG\n";
				text += "if [ $1 -eq 2 ] ; then\n";
				text += "	cp .output_intermediate/CDG.png ./.output\n";
				text += "fi\n";
				text += "# 3 indicates option CFG && DOT\n";
				text += "if [ $1 -eq 3 ] ; then\n";
				text += "	cp .output_intermediate/CFG.dot ./.output\n";
				text += "fi\n";
				text += "# 4 indicates option CFG && PNG\n";
				text += "if [ $1 -eq 4 ] ; then\n";
				text += "	cp .output_intermediate/CFG.png ./.output\n";
				text += "fi\n";
				text += "# 5 indicates option PDG && DOT\n";
				text += "if [ $1 -eq 5 ] ; then\n";
				text += "	cp .output_intermediate/PDG.dot ./.output\n";
				text += "fi\n";
				text += "# 6 indicates option PDG && PNG\n";
				text += "if [ $1 -eq 6 ] ; then\n";
				text += "	cp .output_intermediate/PDG.png ./.output\n";
				text += "fi\n";
				text += "# 7 indicates option PDT && DOT\n";
				text += "if [ $1 -eq 7 ] ; then\n";
				text += "	cp .output_intermediate/PostdominatorTree.dot ./.output\n";
				text += "fi\n";
				text += "# 8 indicates option PDT && PNG\n";
				text += "if [ $1 -eq 8 ] ; then\n";
				text += "	cp .output_intermediate/PostdominatorTree.png ./.output\n";
				text += "fi\n";
				text += "# 9 indicates option SLICE && DOT\n";
				text += "if [ $1 -eq 9 ] ; then\n";
				text += "	cp .output_intermediate/Slice.dot ./.output\n";
				text += "fi\n";
				text += "# 10 indicates option SLICE && PNG\n";
				text += "if [ $1 -eq 10 ] ; then\n";
				text += "	cp .output_intermediate/Slice.png ./.output\n";
				text += "fi\n";
				make_file(".filter_files.sh",text);
				
				// dot_to_png.sh
				text = "#!/bin/bash\n";
				text += "# get in output_intermediate folder and generate all PNG files for each one of the DOT files\n";
				text += "cd .output_intermediate\n";
				text += "dot CDG.dot -o CDG.png -Tpng -Gcharset=latin1\n";
				text += "dot CFG.dot -o CFG.png -Tpng -Gcharset=latin1\n";
				text += "dot PDG.dot -o PDG.png -Tpng -Gcharset=latin1\n";
				text += "dot PostdominatorTree.dot -o PostdominatorTree.png -Tpng -Gcharset=latin1\n";
				text += "dot Slice.dot -o Slice.png -Tpng -Gcharset=latin1\n";
				text += "cd ..\n";
				make_file(".dot_to_png.sh",text);
				
				// final_cleaning.sh
				text = "#!/bin/bash\n";
				text += "# get in input folder to erase all txt files so that it can be removed and also it cannot be seen by the user\n";
				text += "cd .input\n";
				text += "rm *.txt\n";
				text += "cd ..\n";
				text += "rmdir .input\n";
				text += "# get in output_intermediate folder to erase all dot files and png files so that it can be removed and also it cannot be seen by the user\n";
				text += "cd .output_intermediate\n";
				text += "rm *.dot\n";
				text += "rm *.png\n";
				text += "cd ..\n";
				text += "rmdir .output_intermediate\n";
				text += "rm *.txt\n";
				text += "rm *.sh~\n";
				text += "mv .output output\n"; // This makes folder visible
				text += "rm .paths.txt\n";
				text += "echo ";
				text += '"';
				text += "Done.";
				text += '"';
				text += "\n";
				make_file(".final_cleaning.sh",text);

				try {
					Process p = Runtime.getRuntime().exec("sh .process_AG.sh"); 
					p.waitFor();
					BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));
					String line = reader.readLine();
					while (line != null) {    
						System.out.println(line);
						line = reader.readLine();
					}
				} catch(IOException e1) {System.out.println("IOexception");}
				catch(InterruptedException e2) {System.out.println("Interrupted");}
				// here .process_AG.sh is removed
				try {
					Process p = Runtime.getRuntime().exec("rm .process_AG.sh"); 
					p.waitFor();
				} catch(IOException e1) {System.out.println("IOexception");}
				catch(InterruptedException e2) {System.out.println("Interrupted");}
				Graph g = new Graph(slicing_point,list);
				String slicing_error = g.makeGraph();
				if(!(slicing_error.equalsIgnoreCase(""))){
					System.out.println("Slicing error: line "+slicing_error+" does not exist");
					slice = false;
				}
				g.CFGToDot();
				try {
					Process p = Runtime.getRuntime().exec("sh .dot_to_png.sh"); 
					p.waitFor();
					BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));
					String line=reader.readLine();
					while (line != null) {    
						System.out.println(line);
						line = reader.readLine();
					}
				} catch(IOException e1) {System.out.println("IOexception");}
				catch(InterruptedException e2) {System.out.println("Interrupted");}
				// here .dot_to_png.sh is removed
				try {
					Process p = Runtime.getRuntime().exec("rm .dot_to_png.sh"); 
					p.waitFor();
				} catch(IOException e1) {System.out.println("IOexception");}
				catch(InterruptedException e2) {System.out.println("Interrupted");}
				try {
					if((cdg)&&(dot)){
						Process p = Runtime.getRuntime().exec("sh .filter_files.sh 1"); 
						p.waitFor();
					}
					if((cdg)&&(png)){
						Process p = Runtime.getRuntime().exec("sh .filter_files.sh 2"); 
						p.waitFor();
					}
					if((cfg)&&(dot)){
						Process p = Runtime.getRuntime().exec("sh .filter_files.sh 3"); 
						p.waitFor();
					}
					if((cfg)&&(png)){
						Process p = Runtime.getRuntime().exec("sh .filter_files.sh 4"); 
						p.waitFor();
					}
					if((pdg)&&(dot)){
						Process p = Runtime.getRuntime().exec("sh .filter_files.sh 5"); 
						p.waitFor();
					}
					if((pdg)&&(png)){
						Process p = Runtime.getRuntime().exec("sh .filter_files.sh 6"); 
						p.waitFor();
					}
					if((postdt)&&(dot)){
						Process p = Runtime.getRuntime().exec("sh .filter_files.sh 7"); 
						p.waitFor();
					}
					if((postdt)&&(png)){
						Process p = Runtime.getRuntime().exec("sh .filter_files.sh 8"); 
						p.waitFor();
					}
					if((slice)&&(dot)){
						Process p = Runtime.getRuntime().exec("sh .filter_files.sh 9"); 
						p.waitFor();
					}
					if((slice)&&(png)){
						Process p = Runtime.getRuntime().exec("sh .filter_files.sh 10"); 
						p.waitFor();
					}
				} catch(IOException e1) {System.out.println("IOexception");}
				catch(InterruptedException e2) {System.out.println("Interrupted");}
				// here .filter_files.sh is removed
				try {
					Process p = Runtime.getRuntime().exec("rm .filter_files.sh"); 
					p.waitFor();
				} catch(IOException e1) {System.out.println("IOexception");}
				catch(InterruptedException e2) {System.out.println("Interrupted");}				
				try {
					Process p = Runtime.getRuntime().exec("sh .final_cleaning.sh"); 
					p.waitFor();
					BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));
					String line=reader.readLine();
					while (line != null) {    
						System.out.println(line);
						line = reader.readLine();
					}
				} catch(IOException e1) {System.out.println("IOexception");}
				catch(InterruptedException e2) {System.out.println("Interrupted");}
				// here .final_cleaning.sh is removed
				try {
					Process p = Runtime.getRuntime().exec("rm .final_cleaning.sh"); 
					p.waitFor();
				} catch(IOException e1) {System.out.println("IOexception");}
				catch(InterruptedException e2) {System.out.println("Interrupted");}
			} // end if(argsAreRight(args).isEmpty())
			else {
				ArrayList<Integer> mistakes = argsAreRight(args);
				for(int i=0; i<mistakes.size(); i++){
					System.out.println("Flag "+args[mistakes.get(i)]+" does not exist or badly written");
				}
				System.out.println("Type -help for information");
			} 
		} // end else (if("-help"))
	}
}